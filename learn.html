<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <title>Learn: Gmail Spam Remover â€” From Zero to Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;600&display=swap');

        :root {
            --bg: #0a0e1a;
            --surface: #111827;
            --card: #1a2236;
            --border: #1e2d45;
            --primary: #6366f1;
            --primary-glow: rgba(99, 102, 241, .35);
            --accent: #06b6d4;
            --gold: #f59e0b;
            --success: #22c55e;
            --danger: #ef4444;
            --text: #e2e8f0;
            --muted: #64748b;
            --code-bg: #0d1117;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* â”€â”€â”€â”€ HUD â”€â”€â”€â”€ */
        #hud {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 200;
            background: rgba(10, 14, 26, .92);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 10px 24px;
            flex-wrap: wrap;
        }

        .hud-avatar {
            width: 38px;
            height: 38px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
        }

        .hud-level {
            font-weight: 800;
            font-size: 15px;
            color: #fff;
            white-space: nowrap;
        }

        .hud-xp-wrap {
            flex: 1;
            min-width: 120px;
            max-width: 260px;
        }

        .hud-xp-label {
            font-size: 11px;
            color: var(--muted);
            margin-bottom: 3px;
        }

        .hud-xp-bar {
            background: #1e293b;
            border-radius: 20px;
            height: 8px;
            overflow: hidden;
        }

        .hud-xp-fill {
            height: 100%;
            border-radius: 20px;
            background: linear-gradient(90deg, var(--primary), var(--accent));
            transition: width .6s cubic-bezier(.4, 0, .2, 1);
        }

        .hud-stat {
            background: rgba(99, 102, 241, .12);
            border: 1px solid rgba(99, 102, 241, .25);
            border-radius: 8px;
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }

        .hud-stat span {
            color: var(--gold);
        }

        #progress-overall {
            margin-left: auto;
            font-size: 12px;
            color: var(--muted);
        }

        /* â”€â”€â”€â”€ SCREEN SYSTEM â”€â”€â”€â”€ */
        .screen {
            display: none;
            min-height: 100vh;
            padding-top: 70px;
        }

        .screen.active {
            display: block;
        }

        /* â”€â”€â”€â”€ SPLASH â”€â”€â”€â”€ */
        #splash {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-height: 100vh;
            padding: 32px;
            background: radial-gradient(ellipse at 50% 20%, rgba(99, 102, 241, .15) 0%, transparent 65%);
        }

        .splash-icon {
            font-size: 5rem;
            animation: float 3s ease-in-out infinite;
            margin-bottom: 24px;
        }

        @keyframes float {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-12px);
            }
        }

        .splash h1 {
            font-size: clamp(2rem, 5vw, 3rem);
            font-weight: 800;
            background: linear-gradient(135deg, #fff, #a5b4fc, #06b6d4);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 12px;
        }

        .splash p {
            color: var(--muted);
            font-size: 1.05rem;
            max-width: 520px;
            line-height: 1.7;
            margin-bottom: 32px;
        }

        .xp-preview {
            display: flex;
            gap: 12px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 32px;
        }

        .xp-badge {
            background: rgba(99, 102, 241, .12);
            border: 1px solid rgba(99, 102, 241, .3);
            border-radius: 10px;
            padding: 10px 18px;
            font-size: 13px;
            font-weight: 600;
        }

        .btn-start {
            background: linear-gradient(135deg, var(--primary), var(--accent));
            border: none;
            color: #fff;
            font-size: 1.1rem;
            font-weight: 700;
            padding: 16px 40px;
            border-radius: 14px;
            cursor: pointer;
            box-shadow: 0 0 30px var(--primary-glow);
            transition: all .2s;
            font-family: inherit;
        }

        .btn-start:hover {
            transform: translateY(-2px);
            box-shadow: 0 0 45px var(--primary-glow);
        }

        /* â”€â”€â”€â”€ LESSON LAYOUT â”€â”€â”€â”€ */
        #lesson-screen {
            padding-top: 70px;
        }

        .lesson-wrap {
            max-width: 800px;
            margin: 0 auto;
            padding: 32px 20px 80px;
        }

        /* â”€â”€â”€â”€ LESSON CARD â”€â”€â”€â”€ */
        .lesson-card {
            background: var(--card);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 28px 32px;
            margin-bottom: 24px;
            animation: slideIn .4s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(18px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .lesson-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(99, 102, 241, .15);
            border: 1px solid rgba(99, 102, 241, .3);
            color: #a5b4fc;
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: .8px;
            margin-bottom: 16px;
        }

        .lesson-card h2 {
            font-size: 1.5rem;
            font-weight: 800;
            color: #fff;
            margin-bottom: 12px;
        }

        .lesson-card p {
            color: #94a3b8;
            line-height: 1.8;
            margin-bottom: 12px;
            font-size: 15px;
        }

        .lesson-card ul {
            color: #94a3b8;
            padding-left: 20px;
            margin-bottom: 12px;
        }

        .lesson-card li {
            margin-bottom: 6px;
            font-size: 15px;
            line-height: 1.7;
        }

        .lesson-card strong {
            color: #c7d2fe;
        }

        .code-block {
            background: var(--code-bg);
            border: 1px solid #1e293b;
            border-radius: 10px;
            padding: 16px 18px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 13px;
            line-height: 1.7;
            overflow-x: auto;
            margin: 14px 0;
            color: #93c5fd;
        }

        .ck {
            color: #c084fc;
        }

        .cm {
            color: #6ee7b7;
        }

        .cs {
            color: #fca5a5;
        }

        .cn {
            color: #fde68a;
        }

        .visual-box {
            background: rgba(6, 182, 212, .06);
            border: 1px solid rgba(6, 182, 212, .2);
            border-radius: 10px;
            padding: 16px 20px;
            margin: 14px 0;
            font-size: 14px;
            color: #7dd3fc;
        }

        .visual-box strong {
            color: #06b6d4;
            display: block;
            margin-bottom: 6px;
        }

        .flow-row {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
            margin: 10px 0;
        }

        .flow-node {
            background: rgba(99, 102, 241, .15);
            border: 1px solid rgba(99, 102, 241, .3);
            color: #a5b4fc;
            padding: 6px 14px;
            border-radius: 8px;
            font-size: 13px;
            font-weight: 600;
        }

        .flow-arr {
            color: var(--primary);
            font-size: 18px;
        }

        .fun-fact {
            background: rgba(245, 158, 11, .07);
            border-left: 3px solid var(--gold);
            padding: 12px 16px;
            border-radius: 0 8px 8px 0;
            margin: 12px 0;
            font-size: 14px;
            color: #fcd34d;
        }

        .fun-fact::before {
            content: 'ğŸ’¡ Fun Fact: ';
            font-weight: 700;
        }

        /* â”€â”€â”€â”€ QUIZ â”€â”€â”€â”€ */
        .quiz-card {
            background: var(--surface);
            border: 2px solid var(--primary);
            border-radius: 16px;
            padding: 28px 32px;
            margin-bottom: 24px;
            animation: slideIn .4s ease;
        }

        .quiz-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 18px;
        }

        .quiz-icon {
            width: 36px;
            height: 36px;
            background: var(--primary);
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            flex-shrink: 0;
        }

        .quiz-card h3 {
            font-size: 1.1rem;
            font-weight: 700;
            color: #fff;
        }

        .quiz-xp-tag {
            margin-left: auto;
            background: rgba(245, 158, 11, .15);
            color: var(--gold);
            border: 1px solid rgba(245, 158, 11, .3);
            padding: 2px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 700;
        }

        .options {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 8px;
        }

        .opt {
            background: var(--card);
            border: 2px solid var(--border);
            border-radius: 10px;
            padding: 13px 18px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            color: var(--text);
            transition: all .18s;
            text-align: left;
            font-family: inherit;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .opt:hover:not([disabled]) {
            border-color: var(--primary);
            background: rgba(99, 102, 241, .08);
            transform: translateX(3px);
        }

        .opt.correct {
            border-color: var(--success) !important;
            background: rgba(34, 197, 94, .1) !important;
            color: #4ade80;
        }

        .opt.wrong {
            border-color: var(--danger) !important;
            background: rgba(239, 68, 68, .1) !important;
            color: #f87171;
        }

        .opt-key {
            width: 26px;
            height: 26px;
            border-radius: 6px;
            background: rgba(99, 102, 241, .2);
            color: #a5b4fc;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            flex-shrink: 0;
        }

        .feedback-box {
            display: none;
            margin-top: 14px;
            padding: 14px 18px;
            border-radius: 10px;
            font-size: 14px;
            line-height: 1.6;
        }

        .feedback-box.correct {
            background: rgba(34, 197, 94, .1);
            border: 1px solid rgba(34, 197, 94, .3);
            color: #4ade80;
        }

        .feedback-box.wrong {
            background: rgba(239, 68, 68, .1);
            border: 1px solid rgba(239, 68, 68, .3);
            color: #f87171;
        }

        .feedback-box p {
            margin-bottom: 4px;
        }

        /* â”€â”€â”€â”€ NAV BUTTONS â”€â”€â”€â”€ */
        .btn-next {
            background: linear-gradient(135deg, var(--primary), #818cf8);
            border: none;
            color: #fff;
            font-size: 15px;
            font-weight: 700;
            padding: 14px 32px;
            border-radius: 12px;
            cursor: pointer;
            margin-top: 8px;
            display: none;
            transition: all .2s;
            font-family: inherit;
        }

        .btn-next.visible {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            animation: popIn .3s cubic-bezier(.34, 1.56, .64, 1);
        }

        @keyframes popIn {
            from {
                transform: scale(.8);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        .btn-next:hover {
            transform: translateY(-1px);
            box-shadow: 0 8px 24px rgba(99, 102, 241, .4);
        }

        /* â”€â”€â”€â”€ XP TOAST â”€â”€â”€â”€ */
        #xp-toast {
            position: fixed;
            top: 80px;
            right: 20px;
            background: rgba(245, 158, 11, .15);
            border: 1px solid rgba(245, 158, 11, .4);
            color: var(--gold);
            padding: 10px 18px;
            border-radius: 12px;
            font-weight: 700;
            font-size: 14px;
            z-index: 300;
            opacity: 0;
            transform: translateY(-10px) scale(.9);
            transition: all .3s;
            pointer-events: none;
        }

        #xp-toast.show {
            opacity: 1;
            transform: translateY(0) scale(1);
        }

        /* â”€â”€â”€â”€ LEVEL UP â”€â”€â”€â”€ */
        #levelup-overlay {
            position: fixed;
            inset: 0;
            z-index: 500;
            background: rgba(0, 0, 0, .85);
            display: none;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        #levelup-overlay.show {
            display: flex;
            animation: fadeIn .3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .levelup-box {
            background: var(--card);
            border: 2px solid var(--gold);
            border-radius: 24px;
            padding: 48px 56px;
            max-width: 420px;
        }

        .levelup-box h2 {
            font-size: 2rem;
            font-weight: 800;
            color: var(--gold);
            margin: 16px 0 8px;
        }

        .levelup-box p {
            color: var(--muted);
            margin-bottom: 24px;
        }

        .levelup-stars {
            font-size: 2.5rem;
            letter-spacing: 6px;
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.1);
            }
        }

        /* â”€â”€â”€â”€ COMPLETION â”€â”€â”€â”€ */
        #done-screen {
            display: none;
            min-height: 100vh;
            padding-top: 70px;
            align-items: center;
            justify-content: center;
            text-align: center;
            flex-direction: column;
        }

        #done-screen.active {
            display: flex;
        }

        .done-wrap {
            max-width: 600px;
            padding: 40px 24px;
        }

        .done-trophy {
            font-size: 6rem;
            animation: float 3s ease-in-out infinite;
            margin-bottom: 24px;
        }

        .score-card {
            background: var(--card);
            border: 2px solid var(--gold);
            border-radius: 16px;
            padding: 28px;
            margin: 24px 0;
        }

        .score-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .score-item {
            text-align: center;
        }

        .score-num {
            font-size: 2rem;
            font-weight: 800;
            color: var(--gold);
        }

        .score-label {
            font-size: 12px;
            color: var(--muted);
            margin-top: 4px;
        }

        .mastery-bar-wrap {
            margin: 24px 0;
            text-align: left;
        }

        .mastery-label {
            font-size: 13px;
            color: var(--muted);
            display: flex;
            justify-content: space-between;
            margin-bottom: 6px;
        }

        .mastery-bar {
            background: #1e293b;
            border-radius: 20px;
            height: 12px;
            overflow: hidden;
        }

        .mastery-fill {
            height: 100%;
            border-radius: 20px;
            background: linear-gradient(90deg, var(--gold), var(--success));
            transition: width 1.5s ease;
        }

        /* â”€â”€â”€â”€ MISC â”€â”€â”€â”€ */
        .divider {
            border: none;
            border-top: 1px solid var(--border);
            margin: 20px 0;
        }

        .step-indicator {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-bottom: 24px;
            flex-wrap: wrap;
        }

        .step-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--border);
            transition: all .3s;
        }

        .step-dot.done {
            background: var(--success);
        }

        .step-dot.active {
            background: var(--primary);
            transform: scale(1.4);
            box-shadow: 0 0 8px var(--primary);
        }
    </style>
</head>

<body>

    <!-- HUD -->
    <div id="hud">
        <div class="hud-avatar">ğŸ®</div>
        <div>
            <div class="hud-level" id="hud-level">Level 1 â€” Curious Beginner</div>
            <div style="font-size:11px;color:var(--muted)" id="hud-levelname"></div>
        </div>
        <div class="hud-xp-wrap">
            <div class="hud-xp-label">XP <span id="hud-xp-text" style="color:var(--gold);font-weight:700">0</span> /
                <span id="hud-xp-max">100</span></div>
            <div class="hud-xp-bar">
                <div class="hud-xp-fill" id="hud-xp-fill" style="width:0%"></div>
            </div>
        </div>
        <div class="hud-stat">ğŸ”¥ Streak <span id="hud-streak">0</span></div>
        <div class="hud-stat">âœ… Correct <span id="hud-correct">0</span></div>
        <div id="progress-overall" id="hud-progress"></div>
    </div>

    <!-- XP Toast -->
    <div id="xp-toast">+20 XP âš¡</div>

    <!-- Level Up Overlay -->
    <div id="levelup-overlay">
        <div class="levelup-box">
            <div class="levelup-stars">â­â­â­</div>
            <h2 id="lu-title">Level Up!</h2>
            <p id="lu-desc">You unlocked a new level!</p>
            <button class="btn-start" onclick="closeLevelUp()">Continue ğŸš€</button>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• SPLASH â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="splash" class="screen active">
        <div class="splash-icon">ğŸ“§</div>
        <h1>Gmail Spam Remover<br>Interactive Tour</h1>
        <p>Go from zero to expert in one session. Learn how this project works step by step â€” with mini-quizzes, XP
            rewards, and levels that track your mastery.</p>
        <div class="xp-preview">
            <div class="xp-badge">ğŸ§© 9 Lessons</div>
            <div class="xp-badge">â“ 18 Quiz Questions</div>
            <div class="xp-badge">â­ 5 Levels</div>
            <div class="xp-badge">ğŸ† 360 XP to earn</div>
        </div>
        <button class="btn-start" onclick="startLearn()">Start Learning ğŸš€</button>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• LESSON SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="lesson-screen" class="screen">
        <div class="lesson-wrap">
            <div class="step-indicator" id="step-dots"></div>
            <div id="lesson-content"></div>
        </div>
    </div>

    <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• DONE SCREEN â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div id="done-screen">
        <div class="done-wrap">
            <div class="done-trophy">ğŸ†</div>
            <h1 style="font-size:2rem;font-weight:800;color:#fff;margin-bottom:8px;">You Did It!</h1>
            <p style="color:var(--muted);margin-bottom:24px;">You've gone from a complete beginner to a project expert.
                Here's your final score:</p>

            <div class="score-card">
                <div class="score-grid">
                    <div class="score-item">
                        <div class="score-num" id="final-xp">0</div>
                        <div class="score-label">Total XP Earned</div>
                    </div>
                    <div class="score-item">
                        <div class="score-num" id="final-correct">0</div>
                        <div class="score-label">Questions Correct</div>
                    </div>
                    <div class="score-item">
                        <div class="score-num" id="final-streak">0</div>
                        <div class="score-label">Best Streak</div>
                    </div>
                    <div class="score-item">
                        <div class="score-num" id="final-level">1</div>
                        <div class="score-label">Final Level</div>
                    </div>
                </div>
            </div>

            <div class="mastery-bar-wrap">
                <div class="mastery-label"><span>Project Mastery</span><span id="mastery-pct">0%</span></div>
                <div class="mastery-bar">
                    <div class="mastery-fill" id="mastery-fill" style="width:0%"></div>
                </div>
            </div>

            <p style="color:var(--muted);font-size:14px;margin-bottom:24px;">You can now confidently explain the Gmail
                Spam Remover project â€” its data, model, metrics, and architecture â€” to anyone, including judges!</p>
            <button class="btn-start" onclick="restart()">Play Again ğŸ”„</button>
            &nbsp;
            <a href="project_guide.html"
                style="display:inline-block;margin-top:12px;padding:14px 28px;border-radius:12px;background:var(--card);border:1px solid var(--border);color:var(--text);text-decoration:none;font-weight:600;font-size:15px;">ğŸ“–
                Full Guide</a>
        </div>
    </div>

    <script>
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  GAME STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let xp = 0, level = 1, streak = 0, bestStreak = 0, correctCount = 0;
        let totalQuestions = 0, answeredCorrectly = 0;
        let currentStep = 0;
        let questionAnswered = false;

        const LEVELS = [
            { name: 'Curious Beginner', minXp: 0 },
            { name: 'Apprentice Coder', minXp: 80 },
            { name: 'Data Thinker', minXp: 160 },
            { name: 'ML Practitioner', minXp: 260 },
            { name: 'Project Expert ğŸ†', minXp: 330 },
        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STEPS  (lessons + quizzes interleaved)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const STEPS = [

            // â”€â”€ 1. What is spam? â”€â”€
            {
                type: 'lesson', badge: 'Module 1 Â· The Problem', emoji: 'ğŸ“¬',
                title: 'What is Spam and Why Does It Matter?',
                body: `
<p>Every day, billions of emails are sent worldwide. But a huge chunk of them are <strong>spam</strong> â€” unwanted, unsolicited messages that clog your inbox.</p>
<div class="visual-box"><strong>ğŸ“Š Spam by the numbers</strong>45% of all emails sent globally are spam. That's roughly 160 billion spam emails per day.</div>
<p>In the world of email classification, we use two labels:</p>
<ul>
  <li><strong>SPAM</strong> â€” unwanted emails: ads, scams, phishing, fake winners</li>
  <li><strong>HAM</strong> â€” legitimate emails: messages you actually want to read</li>
</ul>
<p>The word "ham" (meaning legitimate email) was coined by early spam researchers to rhyme with "spam" as a pair of opposites.</p>
<div class="fun-fact">The term "spam" in email comes from a Monty Python sketch where Vikings sing "SPAM SPAM SPAM" relentlessly â€” just like spam emails.</div>
<p>Our project automatically identifies which of your Gmail emails are spam and gives you tools to clean them up in seconds â€” powered by Machine Learning.</p>
`},

            {
                type: 'quiz', q: 'What does "HAM" mean in email classification?',
                xp: 20, opts: ['A type of spam email that contains attachments', 'Legitimate email you actually want', 'Emails from unknown senders', 'Marketing newsletters'],
                correct: 1,
                feedback_correct: 'Exactly right! HAM = legitimate email. SPAM = unwanted email. These two labels form the foundation of binary email classification.',
                feedback_wrong: 'Close! In email classification, HAM means legitimate, good email â€” the kind you want in your inbox. SPAM is the opposite.'
            },

            // â”€â”€ 2. Our Dataset â”€â”€
            {
                type: 'lesson', badge: 'Module 2 Â· The Data', emoji: 'ğŸ—„ï¸',
                title: 'Where Does Our Model Learn From?',
                body: `
<p>A Machine Learning model is only as good as its training data. We trained ours on <strong>~65,000 real labelled emails</strong> from two different datasets.</p>
<div class="visual-box">
<strong>ğŸ“ Dataset 1: spam_ham_dataset.csv</strong>Contains 'text' and 'label_num' columns. 1 = spam, 0 = ham.
<br/><br/>
<strong>ğŸ“ Dataset 2: emails.csv</strong>Contains 'text' and 'spam' columns. Same format after renaming.
</div>
<p>We merged both datasets to create one big training pool:</p>
<div class="code-block"><span class="cm"># Merge two datasets</span>
df = pd.concat([df1[['text','label_num']], df2[['text','label_num']]])
<span class="cm"># ~65,000 emails total</span></div>
<p>Why two datasets? More data = better generalisation. If you only train on one narrow source, the model might miss spam patterns it has never seen. Two independent sources give a <strong>wider vocabulary of spam.</strong></p>
<p>The data was then split <strong>80% for training</strong> and <strong>20% for testing</strong> â€” the model never sees the test set during training, so we can fairly measure performance.</p>
`},

            {
                type: 'quiz', q: 'Why did we merge TWO datasets instead of using just one?',
                xp: 20, opts: ['To make the file size bigger', 'To have more variety of spam patterns so the model generalises better', 'Because one dataset was corrupted', 'To duplicate data for higher accuracy'],
                correct: 1,
                feedback_correct: 'Perfect! More diverse data = better generalisation. A model trained on only one source might miss spam patterns from other regions, eras, or types.',
                feedback_wrong: 'Not quite. The reason for merging two datasets is to expose the model to a wider variety of spam patterns, making it more robust on new, unseen emails.'
            },

            // â”€â”€ 3. Text to Numbers â”€â”€
            {
                type: 'lesson', badge: 'Module 3 Â· Preprocessing', emoji: 'ğŸ”¢',
                title: 'How Do We Turn Emails Into Numbers?',
                body: `
<p>Machine Learning models can only work with <strong>numbers</strong>. But emails are text. So we need to convert text into numerical form â€” this process is called <strong>vectorisation</strong>.</p>
<p>We use <strong>CountVectorizer</strong>, which converts each email into a vector of word counts:</p>
<div class="visual-box">
<strong>Example:</strong> "Win free money now free"
â†’ {win:1, free:2, money:1, now:1}
â†’ [0, 0, 1, 2, 1, 1, 0, 0, ...]  (sparse vector)
</div>
<div class="code-block"><span class="ck">from</span> sklearn.feature_extraction.text <span class="ck">import</span> CountVectorizer

vectorizer = CountVectorizer(<span class="cs">stop_words</span>=<span class="cn">'english'</span>)
X_train_vec = vectorizer.fit_transform(X_train)</div>
<p><strong>Stop words</strong> are very common English words like "the", "is", "and" â€” they appear in every email regardless of whether it's spam or not. Removing them reduces noise and keeps only meaningful words.</p>
<div class="fun-fact">After vectorisation, each email is represented as a vector with ~100,000 dimensions â€” one per unique vocabulary word! Most values are 0, so it's stored as a "sparse matrix" to save memory.</div>
<p>The vectorizer is <strong>fitted on training data only</strong>, then used to transform the test data. This prevents "data leakage" â€” the model can't peek at test vocabulary during training.</p>
`},

            {
                type: 'quiz', q: 'What does CountVectorizer do to an email?',
                xp: 20, opts: ['Counts how many emails are spam', 'Converts email text into a vector of word counts', 'Removes spam emails from the dataset', 'Sends the email to a spam folder'],
                correct: 1,
                feedback_correct: 'Spot on! CountVectorizer converts each email into a vector of word counts â€” turning text into numbers that the ML model can understand.',
                feedback_wrong: 'Not quite. CountVectorizer converts email text into a numerical vector (word counts), which is the form ML models need to process data.'
            },

            {
                type: 'quiz', q: 'Why do we remove "stop words" like "the", "is", "and"?',
                xp: 20, opts: ['They are too long to process', 'They appear in every email regardless of class, so they add noise not signal', 'They are only found in spam emails', 'They slow down the server'],
                correct: 1,
                feedback_correct: 'Exactly right! Stop words appear equally in spam and ham â€” they give the model zero useful information about which class an email belongs to. Removing them sharpens the model\'s focus.',
                feedback_wrong: 'The correct reason: stop words appear in ALL emails equally (spam and ham), so they carry no predictive signal. Removing them reduces the feature space and improves performance.'
            },

            // â”€â”€ 4. Naive Bayes â”€â”€
            {
                type: 'lesson', badge: 'Module 4 Â· The Model', emoji: 'ğŸ§ ',
                title: 'How Does Naive Bayes Work?',
                body: `
<p><strong>Multinomial Naive Bayes</strong> is a probabilistic algorithm based on Bayes' theorem. It answers the question:</p>
<div class="visual-box"><strong>Given these words in an email, what is the probability it is spam?</strong>
P(spam | words) = P(words | spam) Ã— P(spam) / P(words)</div>
<p>During training it learns:</p>
<ul>
  <li>What fraction of all emails are spam (<strong>prior probability</strong>)</li>
  <li>How often each word appears in spam emails vs. ham emails</li>
</ul>
<p>At prediction time, when it sees a new email it multiplies probabilities for each word and picks the class (spam or ham) with the higher probability.</p>
<p>The "Naive" part means it <strong>assumes each word is independent</strong> â€” it ignores that "free money" together is spammier than either word alone. This is an oversimplification but works remarkably well in practice.</p>
<div class="code-block"><span class="ck">from</span> sklearn.naive_bayes <span class="ck">import</span> MultinomialNB

model = MultinomialNB()  <span class="cm"># alpha=1.0 (Laplace smoothing)</span>
model.fit(X_train_vec, y_train)
<span class="cm"># Predicts 0 (ham) or 1 (spam)</span>
prediction = model.predict(new_email_vec)</div>
<div class="fun-fact">Naive Bayes spam filtering was popularised by Paul Graham's 2002 essay "A Plan for Spam" and was the algorithm behind early Gmail spam filters!</div>
<p><strong>Laplace smoothing</strong> (alpha=1.0 by default) prevents zero-probability issues. If a word never appeared in training spam but shows up in a test email, without smoothing the spam probability would be 0 â€” making it impossible to classify the email.</p>
`},

            {
                type: 'quiz', q: 'What is the "Naive" assumption in Naive Bayes?',
                xp: 20, opts: ['The model is not very accurate', 'Each word in an email is assumed to be independent of every other word', 'The model assumes all emails are spam by default', 'It only works on short emails'],
                correct: 1,
                feedback_correct: 'Correct! The "naive" independence assumption says every word contributes independently to spam probability â€” ignoring phrase-level patterns. It\'s not realistic but works very well.',
                feedback_wrong: 'The "naive" part refers to the independence assumption: it treats each word as independent of all others. "free" and "money" are treated separately even though together they\'re a much stronger spam signal.'
            },

            // â”€â”€ 5. Training the model â”€â”€
            {
                type: 'lesson', badge: 'Module 5 Â· Training', emoji: 'âš™ï¸',
                title: 'Training the Model â€” Step by Step',
                body: `
<p>Training happens once in <span style="color:#a5b4fc;font-family:monospace">train_model.py</span>. The trained model is saved as files and loaded by the app every time it starts.</p>
<div class="flow-row">
  <div class="flow-node">Load CSVs</div><div class="flow-arr">â†’</div>
  <div class="flow-node">Merge</div><div class="flow-arr">â†’</div>
  <div class="flow-node">Split 80/20</div><div class="flow-arr">â†’</div>
  <div class="flow-node">Vectorise</div><div class="flow-arr">â†’</div>
  <div class="flow-node">Train NB</div><div class="flow-arr">â†’</div>
  <div class="flow-node">Save .pkl</div>
</div>
<div class="code-block"><span class="cm"># Split</span>
X_train, X_test, y_train, y_test = train_test_split(
    df['text'], df['label_num'],
    test_size=<span class="cn">0.2</span>, random_state=<span class="cn">42</span>)  <span class="cm"># 42 = reproducible</span>

<span class="cm"># Vectorise (fit ONLY on train data)</span>
vectorizer = CountVectorizer(stop_words=<span class="cs">'english'</span>)
X_train_vec = vectorizer.fit_transform(X_train)
X_test_vec  = vectorizer.transform(X_test)  <span class="cm"># no fit!</span>

<span class="cm"># Train</span>
model = MultinomialNB()
model.fit(X_train_vec, y_train)

<span class="cm"># Save both model AND vectorizer</span>
joblib.dump(model,      <span class="cs">'spam_model.pkl'</span>)
joblib.dump(vectorizer, <span class="cs">'vectorizer.pkl'</span>)</div>
<p>Notice: vectorizer.fit_transform is called on <strong>train data only</strong>, but vectorizer.transform (no fit) is called on test data. This ensures the model has never "seen" the test vocabulary â€” giving a fair performance measurement.</p>
<div class="fun-fact">random_state=42 makes the split reproducible. Every time you run the code you get the exact same train/test division â€” essential for consistent accuracy reporting.</div>
`},

            {
                type: 'quiz', q: 'Why do we call vectorizer.transform() (not fit_transform) on the TEST data?',
                xp: 20, opts: ['fit_transform is too slow for test data', 'To prevent data leakage â€” the model must not see test vocabulary during training', 'The test data is already vectorised', 'transform returns a different format needed for testing'],
                correct: 1,
                feedback_correct: 'Brilliant! This is a crucial ML principle. Fitting the vectorizer on test data would let the model "peek" at unseen words, inflating accuracy. We fit ONLY on train, then transform test with the same vocabulary.',
                feedback_wrong: 'The correct reason is data leakage prevention. If we fit_transform on test data too, the vectorizer learns the test vocabulary during training â€” meaning the model effectively saw the test data, making accuracy measurements unreliable.'
            },

            // â”€â”€ 6. Metrics â”€â”€
            {
                type: 'lesson', badge: 'Module 6 Â· Measuring Success', emoji: 'ğŸ“Š',
                title: 'How Do We Know If the Model Is Good?',
                body: `
<p>Our model achieves <strong>~98% accuracy</strong> on the test set. But accuracy alone is not enough â€” here's why:</p>
<div class="visual-box"><strong>âš ï¸ The Accuracy Trap</strong>Imagine 95% of emails are ham. A dumb model that ALWAYS predicts "ham" would get 95% accuracy â€” but it catches zero spam! Accuracy alone is misleading on imbalanced datasets.</div>
<p>We use 5 metrics together:</p>
<ul>
  <li><strong>Precision</strong> â€” of all flagged spam, how many actually ARE spam? (high = few false alarms)</li>
  <li><strong>Recall</strong> â€” of ALL real spam, how many did we catch? (high = few spam slipping through)</li>
  <li><strong>F1-Score</strong> â€” harmonic mean of precision and recall (overall balance)</li>
  <li><strong>ROC-AUC</strong> â€” how well the model separates spam from ham at all thresholds (~99% for us)</li>
  <li><strong>Confusion Matrix</strong> â€” shows TP, FP, TN, FN in a 2Ã—2 grid</li>
</ul>
<div class="visual-box">
<strong>Confusion Matrix:</strong>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Predicted HAM | Predicted SPAM
<br/>Actual HAM  &nbsp;[ TN âœ… &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| FP âš ï¸ ]
<br/>Actual SPAM &nbsp;[ FN âŒ &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| TP âœ… ]
</div>
<p>For a spam filter, <strong>False Positives are the worst outcome</strong>. A False Positive means a legitimate email (a job offer, a bank email) gets moved to spam â€” the user might never see it.</p>
`},

            {
                type: 'quiz', q: 'You have a spam filter. It marks a legitimate job offer email as SPAM. What type of error is this?',
                xp: 20, opts: ['True Positive', 'True Negative', 'False Positive', 'False Negative'],
                correct: 2,
                feedback_correct: 'Correct! A False Positive is when a legitimate email (ham) is incorrectly classified as spam. This is the worst error for a user-facing spam filter â€” the user loses real emails.',
                feedback_wrong: 'This is a False Positive. The email is actually ham (negative class), but we predicted spam (positive). False Positive = ham wrongly flagged as spam. The most damaging error in a spam filter.'
            },

            {
                type: 'quiz', q: 'Our model has ~98% accuracy. What does the REMAINING ~2% represent?',
                xp: 20, opts: ['The model is 2% biased', 'Approximately 2% of test emails were misclassified (false positives + false negatives)', 'The model was only trained on 98% of the data', '2% of words were ignored during vectorisation'],
                correct: 1,
                feedback_correct: 'Spot on! The ~2% error rate means roughly 2 in every 100 test emails were misclassified â€” either spam that slipped through (FN) or ham wrongly flagged as spam (FP).',
                feedback_wrong: 'The ~2% represents the model\'s error rate â€” about 2 in 100 emails are misclassified. This includes both false positives (ham flagged as spam) and false negatives (spam not caught).'
            },

            // â”€â”€ 7. Model Comparison â”€â”€
            {
                type: 'lesson', badge: 'Module 7 Â· Why Our Model?', emoji: 'âš–ï¸',
                title: 'We Tested 5 Models â€” Here\'s Why We Chose Naive Bayes',
                body: `
<p>Before choosing Naive Bayes, we benchmarked 5 different classifiers on the exact same dataset and test split:</p>
<div style="overflow-x:auto;border-radius:10px;border:1px solid var(--border);margin:14px 0;">
<table style="width:100%;border-collapse:collapse;font-size:13px;">
<thead><tr style="background:rgba(99,102,241,.15);">
<th style="padding:10px 14px;text-align:left;color:#a5b4fc;">Model</th>
<th style="padding:10px 14px;color:#a5b4fc;">Accuracy</th>
<th style="padding:10px 14px;color:#a5b4fc;">F1</th>
<th style="padding:10px 14px;color:#a5b4fc;">Train Time</th>
</tr></thead>
<tbody>
<tr style="border-top:1px solid var(--border)"><td style="padding:10px 14px;color:#fff;font-weight:700">Naive Bayes â­</td><td style="padding:10px 14px;color:#4ade80">~98%</td><td style="padding:10px 14px;color:#4ade80">~97%</td><td style="padding:10px 14px;color:#4ade80">âš¡ &lt;1s</td></tr>
<tr style="border-top:1px solid var(--border)"><td style="padding:10px 14px;color:var(--muted)">Logistic Regression</td><td style="padding:10px 14px;color:var(--muted)">~98%</td><td style="padding:10px 14px;color:var(--muted)">~98%</td><td style="padding:10px 14px;color:var(--muted)">~3s</td></tr>
<tr style="border-top:1px solid var(--border)"><td style="padding:10px 14px;color:var(--muted)">Linear SVM</td><td style="padding:10px 14px;color:var(--muted)">~99%</td><td style="padding:10px 14px;color:var(--muted)">~99%</td><td style="padding:10px 14px;color:var(--muted)">~4s</td></tr>
<tr style="border-top:1px solid var(--border)"><td style="padding:10px 14px;color:var(--muted)">Random Forest</td><td style="padding:10px 14px;color:var(--muted)">~97%</td><td style="padding:10px 14px;color:var(--muted)">~96%</td><td style="padding:10px 14px;color:var(--muted)">~60s+</td></tr>
<tr style="border-top:1px solid var(--border)"><td style="padding:10px 14px;color:#f87171">KNN</td><td style="padding:10px 14px;color:#f87171">~88%</td><td style="padding:10px 14px;color:#f87171">~82%</td><td style="padding:10px 14px;color:#f87171">~10s</td></tr>
</tbody></table></div>
<p>SVM is ~1% more accurate â€” but takes 4-5Ã— longer to train and predict. Since our app classifies emails <strong>in real time</strong> during every inbox scan, Naive Bayes's microsecond inference speed matters. The accuracy difference is negligible.</p>
<p>KNN performs worst because of the <strong>curse of dimensionality</strong> â€” with 50,000+ word features, "nearest neighbours" in that space become meaningless.</p>
<div class="fun-fact">Naive Bayes was literally invented for spam filtering. Paul Graham's 2002 essay "A Plan for Spam" sparked the modern era of Bayesian email filtering â€” it's the algorithm's home turf.</div>
`},

            {
                type: 'quiz', q: 'Linear SVM scores ~1% higher accuracy than Naive Bayes. So why did we still choose Naive Bayes for production?',
                xp: 20, opts: ['SVM is harder to implement', 'Naive Bayes is faster to train/predict and 1% accuracy difference is negligible for a real-time app', 'SVM does not work with text data', 'The project budget was limited'],
                correct: 1,
                feedback_correct: 'Exactly! In a real-time app, prediction speed matters. Naive Bayes classifies in microseconds vs SVM which is 4-5x slower. A ~1% accuracy trade-off for massive speed gains is worth it.',
                feedback_wrong: 'The key reason is speed vs accuracy trade-off. Naive Bayes predicts in microseconds. SVM takes 4-5x longer per prediction. Since our app classifies emails in real time, Naive Bayes is the pragmatic production choice despite SVM\'s tiny accuracy edge.'
            },

            // â”€â”€ 8. Gmail API â”€â”€
            {
                type: 'lesson', badge: 'Module 8 Â· The API', emoji: 'ğŸ“¬',
                title: 'How Do We Connect to Gmail?',
                body: `
<p>The app connects to your real Gmail inbox using the <strong>Gmail API</strong> with <strong>OAuth 2.0 authentication</strong>.</p>
<div class="flow-row">
  <div class="flow-node">User clicks Login</div><div class="flow-arr">â†’</div>
  <div class="flow-node">Browser opens Google</div><div class="flow-arr">â†’</div>
  <div class="flow-node">User grants permission</div><div class="flow-arr">â†’</div>
  <div class="flow-node">Token saved</div><div class="flow-arr">â†’</div>
  <div class="flow-node">API calls work</div>
</div>
<p><strong>OAuth 2.0</strong> means the user never gives us their password. Instead, Google issues a limited-scope access token. Our scope is <span style="color:#a5b4fc;font-family:monospace">gmail.modify</span> â€” enough to read and move emails, but not to permanently delete them or access other Google services.</p>
<div class="code-block"><span class="cm"># Fetch unread emails</span>
messages = service.users().messages().list(
    userId=<span class="cs">'me'</span>, q=<span class="cs">'is:unread'</span>, maxResults=<span class="cn">50</span>).execute()

<span class="cm"># Decode email body (Gmail API uses base64)</span>
body = base64.urlsafe_b64decode(data).decode(<span class="cs">'utf-8'</span>)

<span class="cm"># Move to spam by changing labels</span>
service.users().messages().modify(userId=<span class="cs">'me'</span>, id=msg_id,
    body={<span class="cs">'removeLabelIds'</span>: [<span class="cs">'INBOX'</span>,<span class="cs">'UNREAD'</span>],
          <span class="cs">'addLabelIds'</span>: [<span class="cs">'SPAM'</span>]}).execute()</div>
<p>Gmail API returns email content encoded in <strong>base64 URL-safe</strong> format â€” we decode it, extract the subject and body, then feed that text string into the SpamFilter model.</p>
<p>Credentials are stored in <span style="color:#a5b4fc;font-family:monospace">credentials.json</span> and the reusable token in <span style="color:#a5b4fc;font-family:monospace">token.json</span> â€” both excluded from GitHub via <span style="color:#a5b4fc;font-family:monospace">.gitignore</span> for security.</p>
`},

            {
                type: 'quiz', q: 'What is OAuth 2.0 used for in this project?',
                xp: 20, opts: ['Encrypting email bodies before classification', 'Letting users log in to Gmail without giving us their password', 'Compressing email attachments', 'Generating spam labels automatically'],
                correct: 1,
                feedback_correct: 'Exactly right! OAuth 2.0 is the industry-standard authorisation protocol. Users grant us a limited-scope token â€” we never see or store their Gmail password.',
                feedback_wrong: 'OAuth 2.0 is the authorisation protocol that lets the user grant our app access to their Gmail without revealing their password. Google issues a scoped token instead, which the user can revoke any time.'
            },

            // â”€â”€ 9. App Flow â”€â”€
            {
                type: 'lesson', badge: 'Module 9 Â· The Full Picture', emoji: 'ğŸ–¥ï¸',
                title: 'How It All Fits Together',
                body: `
<p>The Streamlit app is the glue that connects every component. Here is the complete end-to-end flow:</p>
<div class="flow-row">
  <div class="flow-node">ğŸ‘¤ User</div><div class="flow-arr">â†’</div>
  <div class="flow-node">ğŸ–¥ï¸ Streamlit</div><div class="flow-arr">â†’</div>
  <div class="flow-node">ğŸ“¬ Gmail API</div><div class="flow-arr">â†’</div>
  <div class="flow-node">ğŸ§  SpamFilter</div><div class="flow-arr">â†’</div>
  <div class="flow-node">ğŸ“Š Results</div>
</div>
<p><strong>Streamlit</strong> re-runs the entire Python script on every user interaction (button click, checkbox). To avoid re-loading the model and re-authenticating on every click, we use <span style="color:#a5b4fc;font-family:monospace">st.session_state</span> to persist:</p>
<ul>
  <li><span style="color:#a5b4fc;font-family:monospace">gmail_service</span> â€” the authenticated Gmail API connection</li>
  <li><span style="color:#a5b4fc;font-family:monospace">spam_filter</span> â€” the loaded Naive Bayes model</li>
  <li><span style="color:#a5b4fc;font-family:monospace">messages</span> â€” the last scan results</li>
  <li><span style="color:#a5b4fc;font-family:monospace">authenticated</span> â€” login status</li>
</ul>
<div class="visual-box"><strong>ğŸ“ Project File Map</strong>
app.py â†’ entry point, UI, session state
gmail_service.py â†’ all API calls isolated here
spam_filter.py â†’ model load + predict interface
train_model.py â†’ one-time offline training
spam_model.pkl â†’ saved trained model (~2 MB)
vectorizer.pkl â†’ saved vectorizer (~0.8 MB)</div>
<p>The model and vectorizer are saved as <span style="color:#a5b4fc;font-family:monospace">.pkl</span> files using <strong>joblib</strong>. They are loaded once per session and cached in session state â€” so classification happens in microseconds even for 50 emails.</p>
<div class="fun-fact">The entire ML prediction pipeline â€” vectorise email text, multiply 100k word probabilities, return spam/ham â€” takes less than 1 millisecond per email on any modern laptop!</div>
`},

            {
                type: 'quiz', q: 'What is the purpose of st.session_state in the Streamlit app?',
                xp: 20, opts: ['To store emails in a database', 'To persist data (like the model and login) between script re-runs so the user doesn\'t reload on every click', 'To manage the Gmail API quota', 'To store the app\'s visual theme settings'],
                correct: 1,
                feedback_correct: 'You got it! Streamlit re-runs the whole script on every interaction. session_state is the way to persist objects (model, Gmail connection, scan results) across those re-runs without reloading them each time.',
                feedback_wrong: 'Streamlit re-runs the entire Python script on every button click. Without session_state, the model would reload and the user would need to log in again on every action. session_state persists these objects across re-runs.'
            },

        ];

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  XP & LEVEL SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function addXP(amount) {
            xp += amount;
            const prevLevel = level;
            updateLevel();
            updateHUD();
            showToast('+' + amount + ' XP âš¡');
            if (level > prevLevel) triggerLevelUp();
        }

        function updateLevel() {
            for (let i = LEVELS.length - 1; i >= 0; i--) {
                if (xp >= LEVELS[i].minXp) { level = i + 1; break; }
            }
        }

        function updateHUD() {
            const lv = LEVELS[level - 1];
            const nextLv = LEVELS[level] || null;
            document.getElementById('hud-level').textContent = 'Level ' + level + ' â€” ' + lv.name;
            document.getElementById('hud-xp-text').textContent = xp;
            const maxXp = nextLv ? nextLv.minXp : xp;
            const baseXp = lv.minXp;
            const pct = nextLv ? Math.min(100, Math.round((xp - baseXp) / (maxXp - baseXp) * 100)) : 100;
            document.getElementById('hud-xp-max').textContent = nextLv ? nextLv.minXp : xp;
            document.getElementById('hud-xp-fill').style.width = pct + '%';
            document.getElementById('hud-streak').textContent = streak;
            document.getElementById('hud-correct').textContent = correctCount;
            const total = STEPS.length;
            document.getElementById('progress-overall').textContent = 'Step ' + (currentStep + 1) + ' / ' + total;
        }

        function showToast(msg) {
            const t = document.getElementById('xp-toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 1800);
        }

        function triggerLevelUp() {
            const lv = LEVELS[level - 1];
            document.getElementById('lu-title').textContent = 'Level ' + level + '!';
            document.getElementById('lu-desc').textContent = 'You unlocked: ' + lv.name;
            const ov = document.getElementById('levelup-overlay');
            ov.classList.add('show');
        }
        function closeLevelUp() { document.getElementById('levelup-overlay').classList.remove('show'); }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  STEP RENDERER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function renderStep() {
            questionAnswered = false;
            const step = STEPS[currentStep];
            const container = document.getElementById('lesson-content');

            // dots
            const dots = document.getElementById('step-dots');
            dots.innerHTML = STEPS.map((s, i) => {
                let cls = 'step-dot';
                if (i < currentStep) cls += ' done';
                else if (i === currentStep) cls += ' active';
                return '<div class="' + cls + '" title="Step ' + (i + 1) + '"></div>';
            }).join('');

            if (step.type === 'lesson') {
                container.innerHTML = `
      <div class="lesson-card">
        <div class="lesson-badge">${step.emoji} ${step.badge}</div>
        <h2>${step.title}</h2>
        ${step.body}
      </div>
      <button class="btn-next visible" onclick="nextStep()">Next â†’</button>
    `;
            } else {
                totalQuestions++;
                const keys = ['A', 'B', 'C', 'D'];
                const optsHTML = step.opts.map((o, i) => `
      <button class="opt" id="opt-${i}" onclick="answerQuiz(${i}, ${step.correct}, ${step.xp})">
        <span class="opt-key">${keys[i]}</span> ${o}
      </button>`).join('');

                container.innerHTML = `
      <div class="quiz-card">
        <div class="quiz-header">
          <div class="quiz-icon">â“</div>
          <h3>${step.q}</h3>
          <span class="quiz-xp-tag">+${step.xp} XP</span>
        </div>
        <div class="options">${optsHTML}</div>
        <div class="feedback-box" id="feedback"></div>
      </div>
      <button class="btn-next" id="btn-next-quiz" onclick="nextStep()">Next â†’</button>
    `;
            }

            updateHUD();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }

        function answerQuiz(chosen, correct, xpAmount) {
            if (questionAnswered) return;
            questionAnswered = true;

            const opts = document.querySelectorAll('.opt');
            opts.forEach(o => o.disabled = true);
            opts[chosen].classList.add(chosen === correct ? 'correct' : 'wrong');
            opts[correct].classList.add('correct');

            const step = STEPS[currentStep];
            const fb = document.getElementById('feedback');
            fb.style.display = 'block';

            if (chosen === correct) {
                correctCount++; answeredCorrectly++;
                streak++;
                if (streak > bestStreak) bestStreak = streak;
                fb.className = 'feedback-box correct';
                fb.innerHTML = '<p>âœ… <strong>' + (streak > 1 ? 'ğŸ”¥ ' + streak + ' streak! ' : '') + 'Correct!</strong></p><p>' + step.feedback_correct + '</p>';
                addXP(xpAmount + (streak >= 3 ? 5 : 0)); // streak bonus
            } else {
                streak = 0;
                fb.className = 'feedback-box wrong';
                fb.innerHTML = '<p>âŒ <strong>Not quite.</strong></p><p>' + step.feedback_wrong + '</p>';
                addXP(5); // participation XP
            }

            const btn = document.getElementById('btn-next-quiz');
            btn.classList.add('visible');
            btn.textContent = currentStep < STEPS.length - 1 ? 'Next â†’' : 'Finish ğŸ†';
        }

        function nextStep() {
            currentStep++;
            if (currentStep >= STEPS.length) {
                showDone();
            } else {
                renderStep();
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        //  START / DONE / RESTART
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function startLearn() {
            document.getElementById('splash').classList.remove('active');
            document.getElementById('lesson-screen').classList.add('active');
            renderStep();
        }

        function showDone() {
            document.getElementById('lesson-screen').classList.remove('active');
            const done = document.getElementById('done-screen');
            done.classList.add('active');
            document.getElementById('final-xp').textContent = xp;
            document.getElementById('final-correct').textContent = answeredCorrectly + ' / ' + totalQuestions;
            document.getElementById('final-streak').textContent = bestStreak;
            document.getElementById('final-level').textContent = level;
            const pct = Math.round((answeredCorrectly / totalQuestions) * 100);
            document.getElementById('mastery-pct').textContent = pct + '%';
            setTimeout(() => { document.getElementById('mastery-fill').style.width = pct + '%'; }, 300);
        }

        function restart() {
            xp = 0; level = 1; streak = 0; bestStreak = 0; correctCount = 0;
            totalQuestions = 0; answeredCorrectly = 0; currentStep = 0;
            document.getElementById('done-screen').classList.remove('active');
            document.getElementById('splash').classList.add('active');
            updateHUD();
        }

        // init HUD
        updateHUD();
    </script>
</body>

</html>